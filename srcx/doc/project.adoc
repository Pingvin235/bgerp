= Разработка
:toc:
:toclevels: 4

BGERP - большой проект. Его разрабатывали живые люди, которые родились несовершенными и после долго учились.
В основном - путём проб и ошибок. В данной статье собранны актуальные рекомендации, представленные однако малым количеством <<samples, кода>>.
Поэтому следовать им необходимо, применяя *Правило бойскаута*. 

IMPORTANT: Оставь место стоянки чище, чем оно было до твоего прихода.

Редактируя тот или иной блок кода необходимо уменьшать использование устаревших подходов, методов, классов.
Писать новый код, используя последние рекомендации и параллельно корректировать смежный код.
При тестировании <<workflow, изменения>> будут одновременно проверены и улучшения кода.
Таким образом постепенно качество кода будет расти.
В дальнейшем будут внедрены формальные метрики качества кода: количество предупреждений компилятора, проверки формата и т.п.

[[ide]]
== Проект
=== Среда разработки
The program may be developed at any Java supporting platform:
[square]
* Windows - this time the maintainer uses it;
* Linux;
* MacOS.

Minimal required set of software: 
[square]
* <<kernel/install.adoc#java, OpenJDK>>;
* <<kernel/install.adoc#mysql, MySQL>>;
* <<eclipse, IDE Eclipse>>.

[[env-console]]
==== Console environment Windows
NOTE: Skip this chapter, when you use *NIX OS.

Console link:https://git-scm.com/download/win[client] for version control system <<workflow, GIT>>.

System of <<build, build and publish>> is written on Bash scripts and uses GNU utilities, for Windows may be used:
[square]
* link:https://www.windowscentral.com/install-windows-subsystem-linux-windows-10[WSL] - embedded in Windows virtual Linux machine, tested way;
* link:https://www.omgubuntu.co.uk/how-to-install-wsl2-on-windows-10[WSL 2] - the new version of it, not tested yet;
* link:https://www.cygwin.com/[Cygwin] - Windows ports of GNU utils, not tested.

The best console emulator on Windows link:https://conemu.github.io/[ConEmu] with embedded FAR Manager. 

=== Форматирование 
IDE либо редактор должны быть настроены для отображения пробельных символов.

image::_res/ide_format.png[width='600px']

Проект следует общепринятым соглашениям для оформления кода по каждому из используемых языков программирования.
Отступы: 4 пробела для Java, табуляторы - для всего остального.
Однако в силу исторических причин, многие файлы форматированы по-разному. 
На снимке выше видны например не рекомендуемые в данный момент *для Java* отступы табуляторами.

При приведении в норму формата файлов следует учитывать следующие правила:
[arabic]
. Все новые файлы должны быть корректно форматированы.
. Ни в коем случае не применять оба символа отступов в одном файле: табуляторы и пробелы. Файл в таком случае становится нечитаемым в некоторых редакторах. 
При обнаружении подобных случаев - приводить все отступы в файле к рекомендуемому формату.
. Осторожно совмещать форматирование файлов с внесением <<workflow, изменений>>, это может существенно усложнить анализ в дальнейшем.

[[format-java]]
==== Java
Форматирование Java кода должно соответствовать *Java Conventions* со следующими изменениями.
Описано для форматера Eclipse.

Настройки в *Windows - Preferences - Java - Code style - Formatter*. 
Необходимо открыть стандартный форматер и сохранить под новым именем, изменив параметры:
[square]
* *Indentation - Tab policy* - *Spaces only*
* *Indentation* - *Tab size* - *4*
* *Line Wrapping* - *Maximum line width*  - *150*

*Window - Preferences - Java - Code style - Organize Imports* в двух полях поставить 99 и 1.

Готовый файл форматера в формате Eclipse: link:../../.vscode/formatter.xml[formatter.xml]

[[eclipse]]
=== Eclipse
В данный момент наиболее удобное решение.  
Загрузить *Eclipse for Java EE Developers*, эта сборка уже содержит GIT клиент, редакторы JSP и XML.

Установить плагины:
[square]
* *Buildship Gradle* - поддержка <<build, Gradle>>;
* *AsciiDoctor* - правка <<documentation, документации>>;
* *MoreUnit* - удобная работа с <<unit-test, тестами>>.

Вызвать правым кликом на проекте меню *Refresh Gradle Project*.
Его же вызывать при любом изменении библиотек проекта.

*Window - Preferences - General - Editors - Text Editors* установить галочку *Show whitespace characters*

*Window - Preferences - Team - Git - History* снять галочку *Relative history*

Импортировать <<format-java, форматер Java>> в *Window - Preferences - Java - Codestyle - Formatter*.

=== VS Code
Более быстрая чем Eclipse, лучше поддержка JavaScript, Gradle. 
Недостатки:
[square]
* почти нет поддержки JSP;
* хуже редактор AsciiDoc.

Примеры настройки можно link:../../.vscode/readme.txt[посмотреть] в каталоге `.vscode` в корне проекта.
Форматер Java и отображение пробельных символов там уже включены.

[[ide-run]]
=== Running in IDE
Configuration:
[square]
* Main class: ru.bgerp.Server
* Program arguments: start
* VM arguments: -Dbgerp.setup.data=bgerp_test
* Classpath: *User entries - Advanced - Add folders* нажать и добавить каталог текущего проекта.

Copy `bgerp.properties` to `bgerp_test.propertes`, replace *GENERATED_PASSWORD* on some random value, possible using `pwgen` or similar utility. 

==== Database
MySQL server may be running on any supporting platform, check <<kernel/install.adoc#mysql, configuration>> of it.

For database creation use sequentially the files:
[square]
* `db_create.sql`, `db_init.sql` from link:https://bgerp.org/download/3.0/bgerp.zip[bgerp.zip] - initial structure;
* `bgerp.sql` https://demo.bgerp.bgerp/bgerp.sql - data after running of <<integration-test, integration test>>.

Replace *GENERATED_PASSWORD* in `db_create.sql` to the value from `bgerp_test.properties` but *surrounded by commas*.

Execute mysql commands:
[source, bash]
----
mysql --default-character-set=utf8 -uroot -p < db_create.sql
mysql --default-character-set=utf8 -ubgerp -p < db_init.sql
mysql --default-character-set=utf8 -uroot -p < bgerp.sql
----

For <<db, DB update>> on each start in `.properties` must be set <<kernel/setup.adoc#config-on-start, option>>:
[source]
----
runOnStart+=,ru.bgcrm.util.distr.DevDbUpdater
----

[[structure]]
=== Файлы
Перечень каталогов проекта с описанием.
[square]
* *bin* - скомпилированные IDE Java классы;
* *build* - файлы, относящиеся к <<build, сборке>>;
* *docpattern* - шаблоны плагина <<plugin/document/index.adoc#, Document>>;
* *dyn* - <<kernel/extension.adoc#dyn, динамический код>> с примерами;
* *dyn.ext* - в каталог можно смонтировать динамические классы на машине <<devm, клиента>>; 
* *filestorage* - хранилище файлов при запуске в IDE;
* *lib* - Java библиотеки, не подключенные через <<java-lib, Gradle>>;
* *plugin* - объявления <<plugin, плагинов>>;
* *src* - Java исходные коды;
* *srcx* - исходные файлы <<documentation, документации>>, <<unit-test, Unit тестов>>, <<integration-test, интеграционного теста>>, утилит для сборки; 
* *webapps* - корень <<js-lib, Web приложения>>;
* *work* - каталог создаётся Tomcat для компиляции JSP файлов. 

==== Библиотеки
[[java-lib]]
===== Java  
При link:../../build/bgerp/files/erp.sh[запуске] программы подключаются JAR файлы из следующих каталогов:
[square]
* *lib/app* - непосредственно <<build-erp, классы приложения>>;
* *lib/ext* - сторонние библиотеки, необходимые для работы;
* *lib/custom* - дополнительные библиотеки для <<kernel/extension.adoc#dyn, динамического кода>> и JEXL скриптов.  

Сторонние библиотеки поставляются в отдельном <<build-update, пакете обновления>>. 
Артефакты и версии указываются в файле link:../../build.gradle[build.gradle] для конфигурации *bgerp*.

IMPORTANT: Для данной конфигурации не используются транзитивные зависимости, все необходимые версии библиотек должны быть явно указаны.
Рекомендуемый подход - последовательное добавление минимального набора библиотек до получение работоспособного приложения. 
Таким образом уменьшается размер пакета и упрощается сопровождение. 

Для IDE Eclipse для ускорения изначальной инициализации проекта по-умолчанию отключена загрузка исходных кодов и документации.
[snippet, from="ec", to="}"]
link:../../build.gradle#L18-L24[build.gradle]

[[js-lib]]
===== JS
JS библиотеки располагаются в следующих каталогах:
[square]
* `webapps/js` - располагаются JS файлы самого приложения: ядра и <<plugin, плагинов>>;
* `webapps/lib` - сторонние библиотеки.

Для упрощения отладки используются не минифицированные версии библиотек.

Некоторые сторонние библиотеки пропатчены, все изменения сопровождены комментариями, пример:
[snippet, from="con", to=");", remove-leading="		"]
link:../../webapps/lib/jquery-ui-1.12.1/jquery-ui.js#L8923-L8930[webapps/lib/jquery-ui-1.12.1/jquery-ui.js]

[[devm]]
=== Методика разработки для клиента
BGERP запускается в IDE, с подключением к удалённой базе и биллингу (при необходимости). 
По окончании разработки удалённая база клиента наполнена актуальной конфигурацией и необходимо только обновить сам продукт.
[square]
* Подключаться к клиенту по SSH, пробрасывая соединение к БД и при необходимости к биллингу.
Пример: *ssh user@X.X.X.X -L3307:127.0.0.1:3306 -L8081:Y.Y.Y.Y:8080* 
* Создать свой *bgerp_customer.properties* файл, в нём можно прописывать параметры доступа и конфигурацию. Он не сохранится в GIT.
В нём же можно переопределить URL для подключения к биллингу на locahost.
* Переопределить порт для BGERP, тогда можно будет сохранять в браузере пароли под конкретного клиента.
* Создать конфигурацию запуска в IDE с данным properties.
* Можно поправить *.gitignore* для сохранения custom файлов клиента, если работа происходит в форке.

[[workflow]]
== GIT Workflow
В таблице описаны GIT ветки. 
Для работы с ними используется link:https://docs.google.com/document/d/15NptRsx1qrdiWEew23EFz6gbxD6S12VQpnBQ6X9NbiQ/edit?usp=sharing[стандартный GIT Workflow], 
сходный, например, с ядром Linux.
Основная идея - мерджи производятся только "вниз": с основной ветки на вторичные для получения актуального состояния.
На основную ветку всё переносится посредством патчей, поэтому она имеет линейную структуру.
Вторичные ветки впоследствии могут быть удалены, поскольку вся агрегированная информация из них содержится в основной.

[cols="a,a,a,a", options="header"]
|===
|Ветка
|Базируется на
|Назначение
|<<gitlab-ci, CI>>

|*master*
|
|Стабильная версия программы.
|<<test-integration>>, <<publish-source>>

|*p<ID процесса>-short-description*
|master
|Изменение программы и документации.
|<<test-unit-and-doc>>

|*p11862-documentation*
|master
|Корректировки документации. <<longlife-branch, Долгоживущая ветка>>, периодически переносится на master.
|<<publish-doc>>

|*documentation-change-request*
|p11862-documentation
|Предложения по корректировке документации, могут быть смерджены обратно на p11862-documentation.
|<<test-unit-and-doc>>
|===

Основная ветка проекта - *master*, с неё собираются <<build, сборки>>.
[square]
* Каждое *изменение* должно базироваться на процессе в BGERP BiTel, в котором происходит весь обмен информацией по нему.
* *Идентификатор изменения* - строка *p<ID процесса>*, например *p13455*
* Для каждого изменения создаётся отдельная ветка GIT на базе основной, название начинающееся с идентификатора изменения, разделители - дефисы. 
Например: *p11788-link-filter-title*
* В процессе разработки в ветке допускается любая стратегия коммитов: промежуточные коммиты, ответвления, откаты коммитов.
Рекомендуется пушить промежуточные состояния, используя GIT репозитарий как резервную копию.
* На ветку изменения могут быть периодически смерджена основная ветка для синхронизации с актуальным состоянием и *обязательно перед переносом*.
* Необходимые правки <<documentation, документации>> производятся одновременно с модификацией исходного кода.
* Пакет тестового обновления для клиента, равно как и документацию, можно <<build-update, собирать и опубликовать>> из ветки.
* Ветка должна добавлять файл *build/change.<ID процесса>.txt*, при его отсутствии он создаётся автоматически при <<build-update, сборке изменения>>.
В файле на разных строках должны быть описаны новые функции, исправления и прочие изменения. 
Формат идентичен с *changes.txt*, в который информация переносится автоматически при публикации <<build-erp, обновления>>. 
* По завершению разработки и тестирования у клиента необходимо запросить *перенос* ветки с изменением на основную ветку, 
для этого процесс BGERP перевести в статус *Приёмка*.
* После проверки процесс закрывается, а изменение переносится в виде единственного коммита, 
с комментарием начинающимся с идентификатора изменения в основную ветку.
* Ветка разработки впоследствии может быть удалена. Автор изменения может быть установлен по идентификатору в комментарии.

[IMPORTANT]
====
Невозможно одновременно тестировать несколько изменений параллельно на одной системе и пользоваться ими.
Каждое изменение будет перетирать другое при установке обновления.
В крайнем случае допустимо создание сборочных веток, на которые смердживаются несколько веток изменений.
====

=== Настройка GIT
Пример настройки в файле `$USER_HOME\.gitconfig`:
[source]
----
[user]
	email = shamil@company.com
	name = Shamil Vakhitov
[credential]
	helper = store
[core]
	autocrlf = false
	fileMode = false
[pull]
	rebase = true
----

NOTE: 

=== Команды GIT
Почистить все ссылки на несуществующие более удалённые ветки:
[source]
----
git remote prune origin
----

Получение последних обновлений основной ветки не будучи в ней:
[source]
----
git fetch origin master:master
----

[[accept]]
=== Приёмка и перенос
При принятии изменения производится сравнение ветки с основной.
Поэтому перед передачей изменения необходимо смерджить на ветку актуальное состояние основной.

image::_res/branch_compare.png[]

[[change-file]]
Также необходимо создать и заполнить файл с описанием изменений.
Для этого может быть использована <<build, команда>>:
[bash]
----
bash -c "./gradlew touchChanges"
----

GIT команды для переноса изменений из ветки *pXXXXX-short-change-description* в основную:
[source, bash]
----
git checkout pXXXXX-short-change-description && git pull
git commit --allow-empty -m "MERGED" && git push
git checkout master && git pull
git merge --squash pXXXXX-short-change-description
----

Commit with current GIT user.
[source, bash]
----
git commit -am "pXXXXX Some change description."
----

Or for preserving the author in GitHub. Mapping internal to external mails is available in file `.gitlab-ci-publish-author.sh`
[source, bash]
----
git commit -am "pXXXXX Some change description." --author="Developer Name <internal@gitlab.email>"
----

And final push.
[source, bash]
----
git push
----

Периодически с основной ветки <<build-erp, публикуется обновление>>.

[[longlife-branch]]
=== Долгоживущие ветки
В долгоживущих ветках производятся изменения *не влияющие на функциональность продукта*.
Как-то: корректировка локализации, документации, форматирование кода, тесты.
Процесс изменения при этом не закрывается, а <<accept, перенос>> производится многократно по мере готовности очередной порции изменений.

[[documentation]]
==== Documentation
A particular case of long-life branch is documentation.
The source AsciiDoctor and resource files are placed in `srcx/doc` directory.
Publication of the product manual <<publish-doc, runs>> automcatically from <<workflow, branch>> *p11862-documentation*.

Documentation might be <<build-doc, built>> also locally from any branch and together with a <<build-update, change update package>>.

Documentation changes are recommended to be done at the end of <<workflow, branch development>>,
using <<change-file, change file>> as an intermediate notes. The samples of documentation's format may be found <<samples.adoc#, here>>.

Due the strict references and snippets checking, it is quite possible to have broken <<test-unit-and-doc, state>> of documentation
even without .adoc files. Something like the following:
[source]
----
2020-05-25 12:17:39,149 INFO DocGenerator [main] Processing: srcx/doc/project.adoc
2020-05-25 12:17:39,844 ERROR Snippet [main] Snippet '../../src/ru/bgcrm/struts/action/MessageAction.java' doesn't start from: 'message.se', line number: 205, content: newProcess.setDescription(message.getSubject());
2020-05-25 12:17:39,855 ERROR Snippet [main] Snippet '../../src/ru/bgcrm/struts/action/MessageAction.java' doesn't end on: ');', line number: 71, content: if (message == null)
2020-05-25 12:17:39,859 ERROR Snippet [main] Snippet '../../src/ru/bgcrm/struts/action/MessageAction.java' doesn't start from: 'pu', line number: 241, content:
2020-05-25 12:17:39,860 ERROR Snippet [main] Snippet '../../src/ru/bgcrm/struts/action/MessageAction.java' doesn't end on: '}', line number: 253, content:
2020-05-25 12:17:39,911 ERROR Snippet [main] Snippet '../../webapps/WEB-INF/jspf/user/search/search.jsp' doesn't start from: '<div', line number: 1, content: <%@ page contentType="text/html; charset=UTF-8"%>
2020-05-25 12:17:39,911 ERROR Snippet [main] Snippet '../../webapps/WEB-INF/jspf/user/search/search.jsp' doesn't end on: '/div>', line number: 134, content: <%@ include file="/WEB-INF/jspf/shell_title.jsp"%>
2
---- 

For such cases here is the *fixing algorithm*.
First, find the failing line in `.adoc` file:

image::_res/snippet_fix_1.png[]

After that, using branch comparism, find the new rows and change them in the `.adoc`:

image::_res/snippet_fix_2.png[]

[[localization-branch]]
=== Локализация
Ветки, содержащие только <<localization, локализацию>> интерфейса, следует начинать с долгоживущей ветки *p12136-localization*. 

== Архитектура
BGERP представляет из себя standalone Java приложение с динамическим Web интерфейсом.
Запуск во время разработки может быть <<ide-run, произведён>> прямо в IDE.

Принципиальная структура обработки запросов изображена ниже.
[ditaa]
----
+----------------+             AJAX
|                |    +----+           +-------------+     +----------+
|      HTML      |    | JS |           |             |     |{s}       |
|                +-=->+    +-----+=+-->+ Java Action +<-=->+ MySQL DB |
|                |    |    |           |             |     |          |
|                |    |    +<----+=+---+             |     +----------+
|                |    |    | CHANGE OK +------+------+
|                |    |    | ANY ERROR        |
|                |    |    |                  :
|       +--------+    |    |                  |
|       |  HTML  |    |    |                  v
|       |        +<-=-+    |           +------+------+
|       |Fragment|    |    +<----+=+---+     JSP     |
|       +--------+    +----+   READ    +-------------+
|                |
+----------------+
----

Этапы обработки:
[arabic]
. Запрос формируется с помощью JS из HTML формы и отправляется в метод класса Java Action.
. На запрос изменения отправляется только подтверждение - JSON документ со статусом OK.
. Любое исключение в процессе работы Action приводит к отправке на клиентскую сторону JSON со статусом ERROR.
. На запрос чтения данных в случае корректной обработки отправляется фрагмент HTML документа, встраиваемый на клиенте в нужное место.
Например, таблица со списком пользователей.

[[tech-stack]]
Стек используемых технологий в порядке убывания важности:
[arabic]
. Java - вся <<action, логика>> реализуется в Java коде, поскольку он предоставляет лучшие параметры по удобству разработки, надёжности и быстродействию;
.. MySQL + JDBC - работа с <<db, данными>>;
. HTML + CSS - язык разметки в браузере и таблицы стилей;
. JSP + JSTL - шаблоны отрисовки HTML страниц, уровень <<ui, представления>>;
. JS + JQuery - скриптовый язык для динамических возможностей на странице браузера, используется минимально в виде готовых вызовов фреймворка.

IMPORTANT: Избегать смешения слоёв: логики вне Java, представления вне JSP, манипулирования данными вне MySQL.

[[db]]
=== БД
<<kernel/db.adoc#, Структура базы>> документируется в общем <<documentation, процессе>>, одновременно c внесением изменений.
В приложение база создаётся и <<kernel/install.adoc#update, обновляется>> набором SQL patch скриптов `build/update/patch*.sql`.
При <<ide-run, запуске в IDE>> скрипты могут быть выполнены автоматически.

[[action]]
=== Логика Java Actions
Action классы определяются в `struts-config*.xml` файлах, и привязываются к URL запроса. Имя метода передаётся в HTTP параметре запроса *action*.
Если параметр отсутствует, то вызывается *unspecified* метод, подобный способ нежелателен.

Пример объявления акшена с форвардом:
[snippet, from="<ac", to="on>", remove-leading="		"]
link:../../webapps/WEB-INF/struts-config-blow.xml#L4-L8[webapps/WEB-INF/struts-config-blow.xml]

Акшены должны расширять класс javadoc:ru.bgcrm.struts.action.BaseAction[], методы возвращать результат через вызов *data* либо *status*.
Первый метод обрабатывается JSP страницей-форвардом и высылает HTML на клиент. Второй - предназначен для выполнения изменений и возвращает только JSON формат с результатом выполнения.

[[form-object]]
В каждый вызов акшена передаётся *супер объект form* javadoc:ru.bgcrm.struts.form.DynActionForm[], содержащий контекст выполнения:
[square] 
* пользователь;
* параметры запроса, вспомогательные методы для их разбора.

CAUTION: Не использовать устаревший формат акшенов с параметрами HttpClientRequest и HttpClientResponse, они есть в form. 

Фрагмент читающего акшен метода с форвардом.
[snippet, from="pu", to="}", remove-leading="    "]
link:../../src/ru/bgerp/plugin/blow/struts/action/BoardAction.java#L38-L58[ru.bgerp.plugin.blow.struts.action.BoardAction]

Результат перенаправляется на JSP страницу:
link:../../webapps/WEB-INF/jspf/user/plugin/blow/board/show.jsp[webapps/WEB-INF/jspf/user/plugin/blow/board/show.jsp].

В этом же *form* следует передавать данные для отрисовки JSP, за исключением различных вспомогательных справочников.
Для этого используется поле *response* формы.
При *responseType=json*, всё отправленное в response сериализуется в JSON, именно поэтому справочники следует помещать в HttpResponse.

[snippet, from="pu", to="}", remove-leading="    "]
link:../../src/ru/bgcrm/plugin/dispatch/struts/action/DispatchAction.java#L46-L52[ru.bgcrm.plugin.dispatch.struts.action.DispatchAction]

==== Именование
Классы акшенов должны располагаться в пакете `..struts.action`, имя класса оканчиваться на *Action*. 
Рекомендуемая схема именования методов:
[arabic]
. опционально имя обрабатываемого объекта, если класс работает с несколькими объектами;
. глагол, определяющий операцию, для CRUD это: *list*, *get*, *update*, *delete*;

Примеры имён методов из javadoc:ru.bgcrm.struts.action.admin.UserAction[]:
[square]
* permsetList;
* permsetGet;
* permsetUpdate.

В javadoc:ru.bgcrm.struts.action.admin.AppAction[]:
[suare]
* status - статус приложения;
* update - установка обновления;
* userLoggedList - список авторизовавшихся пользователей.

Форвард рекомендуется называть так же как метод:
[snippet, from="<action path=\"/admin", to="</action>", remove-leading="		"]
link:../../webapps/WEB-INF/struts-config.xml#L66-L69[webapps/WEB-INF/struts-config.xml]

==== Проверка прав
Все методы акшенов должны быть объявлены в файле `plugin/action/kernel.xml` для ядра либо `plugin/action/{PLUGIN}.xml` для плагина.
Пример объявления акшенов плагина Blow: link:../../plugin/action/blow.xml[blow.xml]
Действия из данных файлов образуют дерево, использующееся для <<kernel/setup.adoc#user, разграничения доступа>>.

Каждое действия идентифицируется классом и методом, разделёнными точкой с запятой. 
Через запятую после основного идентификатора можно указать дополнительные, например, при переименовании классов либо методов.
Это позволяет обеспечить обратную совместимость ранее записанных в БД привелегий. При следующем сохранении набора прав будет использован новый идентификатор.

[snippet, from="<item ti", to="с\"/>", remove-leading="		"]
link:../../plugin/action/kernel.xml#L152-L153[plugin/action/kernel.xml]

Вспомогательные действия, которые должны быть постоянно разрешены помечаются атрибутом *allowAll="1"*.

[[exception]]
==== Обработка ошибок
Исключение прерывает выполнение акшена, прерывает тразакцию в <<db, БД>>, ответ отправляется всегда в JSON формате.
Обработка исключений производится централизованно в javadoc:ru.bgcrm.struts.action.BaseAction[], методы DAO либо обработчики скриптов должны просто выбрасывать их все наружу. 
Соответственно в декларациях методов акшенов и DAO должно значиться *throws java.lang.Exception*.

Класс javadoc:ru.bgcrm.model.BGException[] используется для исключений, генерируемых самой системой, в чистом виде нужен весьма редко.

Его наследник класс javadoc:ru.bgcrm.model.BGMessageException[] используется для отправки <<localization, локализованного>> 
уведомления пользователю, без записи сообщения в лог. Пример:

[snippet, from="for (", to=");", remove-leading="            "]
link:../../src/ru/bgcrm/event/listener/ProcessClosingListener.java#L39-L41[ru.bgcrm.event.listener.ProcessClosingListener]

[[action-db]]
==== Работа с БД
Работа с базой данных выполняется через отдельные Java DAO (Data Access Objects) классы. Непосредственно в акшенах используются уже они. 
Обработка запросов <<action, акшенами>> производится транзакционно: транзакция начинается перед вызовом метода, далее подверждается (COMMIT) при возврате
результатов без ошибок либо отменяется (ROLLBACK) при выбросе исключения.

Соединение с базой передаётся в параметрах *con* акшен методов. Также есть варианты методов с параметром *conSet* (javadoc:ru.bgcrm.util.sql.ConnectionSet[]), выдающим соединения по отдельному вызову.
Данный способ подходит для методов не требующих соединения с БД, либо же наоборот, требующих несколько видов соединений: реплики или мусорной для некритичных данных БД (пока не поддержана).  

Имена таблиц указываются в константах, для повышения связанности кода, например: javadoc:ru.bgcrm.dao.Tables[]
Если таблица используется только в единственном DAO классе, то константу с её именем делать приватной: javadoc:ru.bgcrm.plugin.fulltext.dao.SearchDAO[]

Для сборки запросов рекомендуется использование класса link:https://docs.oracle.com/en/java/javase/11/docs/api/java.sql/java/sql/PreparedStatement.html[java.sql.PreparedStatement]
либо более удобной его обёрткой ru.bgcrm.util.sql.PreparedDelay[]. Второй класс удобен возможностью склеивать как запросы, так и параметры и не указывать
номер позиции устанавливаемых параметров.

[[cache]]
==== Кэши
Кэширование во внутренних Map и List используется для ускорения в сотни раз получения справочных значений при 
<<ui, построении UI>>, либо <<kernel/extension.adoc#jexl-process-context, JEXL скриптах>>.
Map объекты позволяют получать объекты по коду, List - упорядоченный по алфавиту список значений.
Примеры кэшируемых объектов: пользователи, их группы, типы процессов, конфигурации.
Полный список можно увидеть в классе link:../../src/ru/bgcrm/servlet/filter/SetRequestParamsFilter.java[ru.bgcrm.servlet.filter.SetRequestParamsFilter]

IMPORTANT: Рекомендуется всегда когда возможно использовать в первую очередь кэши для получения справочников, избегая лишних запросов к БД.

Редактирование справочников происходит напрямую с БД, после редактирования кэш сбрасывается.
[snippet, from="pu", to="}"]
link:../../src/ru/bgcrm/struts/action/admin/UserAction.java#L93-L99[ru.bgcrm.struts.action.admin.UserAction]

[[ui]]
=== Представление JSP
HTML страницы отрисовываются на серверной стороне <<kernel/extension.adoc#jsp, JSP шаблонами>>, получая даннные от Actions и <<cache, кэшей>>.
UI реализован из унифицированных компонентов таким образом, что в большинстве случаев что не требуется устанавливать стили,
писать дополнительные JS обработчики. Примеры <<sample-jsp-ui, кода JSP UI>>.

==== Теги
Компоненты выполнены как JSP теги, объявлены в каталоге `webapps/WEB-INF/tags`.
<<ide, IDE Eclipse>> поддерживает автодополнение при их использовании.

image::_res/ide_jsp_tag.png[width='600px']

Обзор использования тегов с элементами управления пользователя вы можете посмотреть в файле link:../../webapps/test.jsp[webapps/test.jsp], 
для выполнения шаблона наберите в браузере http://<host>:<port>/test.jsp, для Demo системы: http://demo.bgerp.ru/test.jsp

Пункты меню, устанавливающие соответствие между URL оснастки и Java Action определяются для ядра в файле 
link:../../webapps/WEB-INF/jspf/user/menu.jsp[webapps/WEB-INF/jspf/user/menu.jsp], для плагинов - через точку <<plugin-ui-menu, расширения>>.

==== Функции
JSP функции объявлены в каталоге `webapps/WEB-INF/tld`.
Также как и для тегов для IDE поддерживает автодополнение.
Используются, например, для <<sample-date-format, форматирования выводимых времён>>.

==== Идентификация элементов
В HTML DOM все идентификаторы элементов глобальные с использованием атрибутов `class` и `id`. Их довольно сложно отслеживать на предмет 
используемости и уникальности, а кроме того приложение обязательно должно быть одностраничным, что мешает сохранять состояние на скрытых элементах. 
Для обхода этого неудобства в проекте используется привязка JS обработчиков через HTML атрибуты onClick и т.п., с применением конекстной переменной `this`.
Либо генерируется уникальный идентификатор с помощью JSP функции `u:uiid()`, который также подставляется в сгенерированный вызов JS.

==== Сохранение контекста
JSP страница хранит все переменные глобально. В сочетании с инклудами и большими шаблонами это может создавать неудобства.
Для обхода проблемы используется тег восстановления контекста `<u:sc>`, все переменные созданные внутри него сбрасываются при выходе.

[[js]]
=== JS (Java Script)
JS используется для обеспечения динамического поведения на странице клиента.
Скрипты и библиотеки к ним располагаются по следующим <<js-lib, путям>>, <<plugin, плагины>> могут обладать собственными скриптами. 
В некоторых местах код JS генерируется на стороне сервера в JSP шаблонах.
Данный способ не очень предпочтителен, поскольку сложен для отладки в браузере.

Функции системы разбиты по объектам, выстроенных в иерархию от корневого объекта *+++$$+++*.
Например: link:../../webapps/js/kernel.ajax.js[+++$$+++.ajax], link:../../webapps/js/kernel.ui.js[$$.ui]
Обычная схема привязки JS кода к HTML: установка обработчиков событий с вызовом функций, <<sample-jsp-ui, пример AJAX>>. 

Устаревшие JS функции помечаются следующим образом:
[snippet, from="fun", to="}"]
link:../../webapps/js/kernel.ajax.js#L352-L357[webapps/js/kernel.ajax.js]

При их вызове в console бразузера выводится сообщение: "Deprecated", при клике по которому можно найти устаревший вызов.
Использование подобных функций не допускается в новом коде и должно уменьшаться в существующем.

[[plugin]]
=== Плагины
Всякая логически обособленная функциональность должна быть вынесена в плагин.
Особенностью плагинов является их изолированность. Каждый плагин работает с ядром,
ядро не знает особенностей конкретного плагина, плагины не знают друг о друге.
Под *знанием* тут подразумевается полагание на конкретное API, вызовы.

В каких местах производится правка для плагина:
[square]
* XML объявление плагина *plugin/name.xml*, там же объявляются точки расширений.
* Таблицы БД при необходимости создаются и модифицируются в *build/update/patch.sql*
* Java код плагина в пакете *ru.bgerp.plugin.name*
* Java библиотеки подключать в *build.gradle* после комментария: "библиотеки, попадающие в сборку BGERP"
* JS код плагина в файле *webapps/js/name.js*, подключается через точку расширения в XML объявлении.
* Actions плагина в файле *webapps/WEB-INF/struts-config-name.xml*
* Действия из обычного интерфейса должны быть объявлены в *action/plugin.xml* для контроля прав.
* JSP плагина в *webapps/WEB-INF/jspf/user/plugin/name*
* Для добавления плагина в сборку править *build/update/build.xml*

==== XML декларация
[snippet]
link:../../plugin/blow.xml[]

В файле определяются точки расширения:
[square] 
* JSP шаблоны;
* JS файлы;
* *package* - пакет плагина, в котором должен быть размещён главный класс.

==== Java класс плагина
link:../../src/ru/bgerp/plugin/blow/Plugin.java[ru.bgerp.plugin.blow.Plugin]

В классе плагина могут определяться слушатели событий:
[snippet, from="pu", to="}", remove-leading="	"]
link:../../src/ru/bgcrm/plugin/slack/Plugin.java#L14-L20[ru.bgcrm.plugin.slack.Plugin]

[[plugin-ui-menu]]
==== Пункты меню
Объявление точки расширения в XML декларации:
[snippet, from="<en", to=">", remove-leading="	"]
link:../../plugin/blow.xml#L4-L4[plugin/blow.xml]

Добавление пункта с помощью тега JSP: link:../../webapps/WEB-INF/jspf/user/plugin/blow/menu_items.jsp[webapps/WEB-INF/jspf/user/plugin/blow/menu_items.jsp]

[[plugin-js]]
==== JavaScript
Объявление точки расширения в XML декларации:
[snippet, from="<en", to=">", remove-leading="	"]
link:../../plugin/blow.xml#L5-L5[plugin/blow.xml]

Файл со скриптом: link:../../webapps/js/pl.blow.js[webapps/js/pl.blow.js]

[[custom-level]]
=== Кастомизация
Одним из изначальных приоритетов системы была расширяемость и гибкость.
Поэтому стандартный функционал может быть <<kernel/extension.adoc#tech-choice, расширен>> несколькими способами.

Следует однако понимать, что наиболее эффективный путь разработки и долгосрочной поддержки функциональности 
- реализация в виде штатного плагина либо части ядра, с вынесением необходимого минимума параметров в конфигурацию.
JEXL скрипты либо динамический код могут быть использованы для быстрого прототипирования,
либо реализации *исключительно специфичной для данной инсталляции* логики.

Практика показывает, что из всего набора кастомизированных попыток постепенно 
выявляются удачные решения, которые подходят значительному числу пользователей.
Такие необходимо переносить в основной код, делая частью системы и совместно развивая её дальше.

Следующая диаграмма визуально отображает данную динамику трансформации совокупной массы программного кода разных типов.
Объём кода учитывается для всех клиентов, бОльший объём из разрозненных *решений* преобразуется в меньший объём более универсального кода единого *продукта*.
 
[ditaa]
----
+--------------+   +--------------+  +-----------------------+
|              |   |              |  |                       |
|              |   |              |  |                       |
|  Custom JSP  |   |  Dyn Code    |  |      Configuration    |
|              |   |              |  |                       |
|              |   |              |  |         +JEXL         |
|              |   |              |  |                       |
+------+-------+   +-----------+--+  +-+----------+----------+
       |                       |       |          |
       v                       v       v          v
+------+-------+           +---+-------+-+ +------+------+
| Standard JSP |           |  Java Code  | |Configuration|
+--------------+           +-------------+ +-------------+
----

[[localization]]
=== Локализация
Все сообщения в логах не локализуются и выводятся на английском языке.
Локализуется интерфейс и сообщения, адресованные пользователю системы.
Язык системы задаётся глобально в <<kernel/setup.adoc#config, конфигурации>>.
Файлы локализации размещаются в *plugin/i18n* в формате XML.
Новые локализирующие фразы должны добавляться в начало списка в файле.

Локализация отдельно от <<workflow, изменения>> может быть выполнена в <<localization-branch, отдельной ветке GIT>>.

NOTE: Для отключения в момент разработки кэширования локализаций установите в конфигурации *localization.cache=0*

Ключом локализирующей фразы выступает первая запись на любом языке, например русском:
[source, xml]
----
<p><ru>Требуется повторная авторизация</ru><en>Re-authorization is required</en></p>
----

Возможно использование коротких сокращённых ключей, представляя их в виде записей на особом системном языке, например:
[source, xml]
----
<p><sys>reauth.message</sys><ru>Требуется повторная авторизация</ru><en>Re-authorization is required</en></p>
----

Для изменения надписей на кнопках в интерфейсе, следует применять добавиление отдельной локализации(изменять Русскую локализацию не получится, так как она испольузется как ключ), например меняем кнопку в мастере создания, через язык my:
[source, xml]
----
<p><ru>Завершить</ru><en>Finish</en><my>Создать заявку</my></p>
----

Локализация может выполняться в JSP шаблонах и Java акшенах. В JS коде локализация доступна, только если он генерируется JSP.

В коде JSP шаблона вызов локализации из примера выше выглядит следующим образом:
[source, jsp]
----
$('#loginForm').dialog({
	modal: true,
	draggable: false,
	resizable: false,
    title: "${l.l('Требуется повторная авторизация')}",
    position: { my: "center top", at: "center top+100px", of: window }
});
----

При выполнении <<action, акшена>> в объект *l* передаётся локализационный контекст, содержащий фразы для ядра и вызываемого плагина.

[snippet, from="message.se", to="());", remove-leading="        "]
link:../../src/ru/bgcrm/struts/action/MessageAction.java#L227-L227[ru.bgcrm.struts.action.MessageAction]

== Именование
=== Переменные конфигураций, функции JS, HTTP StyleId
[square]
* Все переменные конфигурации от плагинов начинать как <plugin>:
* Все функции JS плагинов начинать с префикса <plugin>-
В других местах тире запретить в названии функции.
* Все идентификаторы (style id) DOM элементов для плагинов начинать как <plugin>-
В других местах тире запретить в названиях  идентификаторов.

=== База данных
1) Таблицы и поля в них именовать с нижним подчёркиванием.
process_id
param_id

=== Переменные Java, параметры HTTP запросов, переменные в JSP
В camelCase нотации:
processId
paramId

=== Дата - поле сущности
Если в поле только дата, то:
createDate - Java - тип java.util.Date
create_date - БД - тип date

Если в поле дата + время, то:
createTime - Java - тип java.util.Date
create_dt - БД - тип datetime

=== Дата - период сущности
В бинах дату периода хранить с типом java.util.Date с именем:
dateFrom
dateTo

Соответственно методы получения и установки:
setDateFrom
setDateTo
getDateFrom
getDateTo

CAUTION: Не использовать для хранения в бинах Calendar.
Если нужно конверить в календарь или из календаря - использовать TimeUtils.

Если нужно хранить время, то делаем:
timeFrom
timeTo

Также тип java.util.Date.

Calendar использовать во всяких калькуляторах/тарификаторах, когда реально нужно постоянно двигать дату.

В базе использовать поля from_date и to_date, тип date.

from_dt, to_dt - тип datetime.

Неограниченные даты - NULL.

[[samples]]
== Примеры кода
Так как система очень быстро меняется, то здесь собираются примеры актуального кода, рекомендуемого к использованию.
Сниппеты извлекаются непосредственно из исходных файлов проекта, поэтому всегда достоверны.
При необходимости воспользуйтесь IDE для поиска классов или файлов.

=== Сохранение последних параметров запроса пользователя
Например, фильтров интерфейса. Используется метод *restoreRequestParams* в: javadoc:ru.bgcrm.struts.action.BaseAction[]

Сохранение значения:
[snippet, from="resto", to=");", remove-leading=    "]
link:../../src/ru/bgcrm/struts/action/MessageAction.java#L87-L87[ru.bgcrm.struts.action.MessageAction]

Восстановление:
[snippet, from="pu", to="}", remove-leading="    "]
link:../../src/ru/bgcrm/struts/action/MessageAction.java#L263-L275[ru.bgcrm.struts.action.MessageAction]

Сохранение плюс восстановление сразу:
[snippet, from="//", to=");", remove-leading="    "]
link:../../src/ru/bgcrm/struts/action/ProcessLinkAction.java#L52-L56[ru.bgcrm.struts.action.ProcessLinkAction]

=== Отображение на вкладке количества элементов
Например, количества связанных процессов. Сохраняется при первом вызове. 
Используется класс javadoc:ru.bgcrm.model.IfaceState[]

Обновление значения:
[snippet, from="// п", to="}", remove-leading="        "]
link:../../src/ru/bgcrm/struts/action/ProcessLinkAction.java#L221-L228[ru.bgcrm.struts.action.ProcessLinkAction]

Show in JSP:
[snippet, from="<c:if", to="if>", remove-leading="						"]
link:../../webapps/WEB-INF/jspf/user/process/process/process_editor.jsp#L82-L96[webapps/WEB-INF/jspf/user/process/process/process_editor.jsp]

[[sample-date-format]]
=== Форматирование даты и времени
При форматировании дат и времени в Java либо JSP для независимости от текущей локали и унификации используются форматы вида:
[square]
* *ymd* - год, месяц, день;
* *ymdh* - год, месяц, день, час;
* *ymdhm* - год, месяц, день, час, минута;
* *ymdhms* - год, месяц, день, час, минута, секунда.

В Java коде для форматирования дат используется класс javadoc:ru.bgcrm.util.TimeUtils[], 
в нём же есть константы с форматами.

В JSP - функция `u:formatDate()`:
[snippet, from="<td", to="/td>", remove-leading="		"]
link:../../webapps/WEB-INF/jspf/user/plugin/task/task_list.jsp#L18-L19[webapps/WEB-INF/jspf/user/plugin/task/task_list.jsp]

=== Бины конфигурации
Для ускорения парсинга и валидации используются Java объекты с классом, наследующим javadoc:ru.bgcrm.util.Config[].
Например: link:../../src/ru/bgcrm/model/config/IsolationConfig.java[ru.bgcrm.model.config.IsolationConfig].
Данная конфигурация поддерживает конструктор с флагом валидации, что позволяет проверять синтаксис при сохранении.

Бины конфигурации могут быть получены и в JSP:
[snippet, from="<c:", to="/>"]
link:../../webapps/WEB-INF/jspf/user/plugin/task/task_list.jsp#L4-L4[webapps/WEB-INF/jspf/user/plugin/task/task_list.jsp]

[[sample-logging]]
=== Логирование
==== Java
Используется класс логгер javadoc:ru.bgerp.util.Log[], базирующийся на фрейморке <<kernel/extension.adoc#log4j, Log4j>>.
При запуске в IDE конфигурационный файл из дистрибутива link:../../build/bgerp/files/log4j.properties[build/bgerp/files/log4j.properties]
может быть скопирован в корень проекта и изменён требуемым образом.

Для логирования в <<action, actions>> использовать *protected* переменную `log`.

В Java классах создавать *static final* переменную класса:
[snippet, from="pub", to=");"]
link:../../src/ru/bgcrm/worker/MessageExchange.java#L16-L19[ru.bgcrm.worker.MessageExchange]

Вывод сообщения при исключении:
[snippet, from="try", to="}", remove-leading="					"]
link:../../src/ru/bgcrm/worker/MessageExchange.java#L60-L64[ru.bgcrm.worker.MessageExchange]

==== JS
Вывод отладки вместо console.log:
[snippet, from="con", to="};"]
link:../../webapps/js/kernel.shell.js#L5-L12[webapps/js/kernel.shell.js]

Enabling debug:
[snippet, from="$$.", to="0,"]
link:../../webapps/js/kernel.js#L18-L22[webapps/js/kernel.js]

=== Постраничный вывод
Вывод результатов в JSP и отображение формы:
[snippet, from="<c:", to="rm>", remove-leading="		"]
link:../../webapps/WEB-INF/jspf/user/process/process/link_process_list.jsp#L56-L64[webapps/WEB-INF/jspf/user/process/process/link_process_list.jsp]

Java action:
[snippet, from="//", to="id);", remove-leading="        "]
link:../../src/ru/bgcrm/struts/action/ProcessLinkAction.java#L212-L214[ru.bgcrm.struts.action.ProcessLinkAction]

[[sample-jsp-ui]]
=== JSP UI
Простой справочник с промотчиком страниц, вызов редактора AJAX: link:../../webapps/WEB-INF/jspf/admin/process/status/list.jsp[webapps/WEB-INF/jspf/admin/process/status/list.jsp]

Отправка AJAX для сохранения, выхода, либо восстановления данных в <<kernel/process/index.adoc#type, редакторе свойств типа процесса>>: 
[snippet, from="<div", to="/div>"]
link:../../webapps/WEB-INF/jspf/admin/process/type/properties.jsp#L191-L196[webapps/WEB-INF/jspf/admin/process/type/properties.jsp]

Рекурсивный инклуд:
[snippet, from="<c:", to="if>", remove-leading="					"]
link:../../webapps/WEB-INF/jspf/admin/user/check_tree_item.jsp#L48-L50[webapps/WEB-INF/jspf/admin/user/check_tree_item.jsp]

Инклуд результата выполнения акшена:
[snippet, from="<c:", to="/>", remove-leading="			"]
link:../../webapps/WEB-INF/jspf/admin/user/user/update.jsp#L161-L166[webapps/WEB-INF/jspf/admin/user/user/update.jsp]

Flex layout, использование констант из Java классов, кнопка вывода рядом с полем:
[snippet, from="<div", to="/div>", remove-leading="				"]
link:../../webapps/WEB-INF/jspf/user/search/search.jsp#L88-L107[webapps/WEB-INF/jspf/user/search/search.jsp]

Обновление оснастки при повторном переходе в неё:
[snippet, from="<script", to="/script>"]
link:../../webapps/WEB-INF/jspf/user/log/log.jsp#L22-L28[webapps/WEB-INF/jspf/user/log/log.jsp]

Отправка AJAX запроса, блокировка кнопки при долгом выполнении действия:
[snippet, from="<bu", to="on>"]
link:../../webapps/WEB-INF/jspf/admin/dynamic/dynamic.jsp#L22-L27[webapps/WEB-INF/jspf/admin/dynamic/dynamic.jsp]

[[build]]
== Build and publish
Проект сконфигурирован в формате Gradle, конфигурационный файл link:../../build.gradle[build.gradle].
For build and publish except Java is required <<env-console, console enviroment>> with available *ant*, *ssh* and *rsync* packages.

NOTE: Здесь и далее команды приведены в расчёте на WSL окружение, в *NIX системах префикс `bash -c` не требуется.

[[build-doc]]
=== Документация
[source]
----
bash -c "./gradlew clean buildDoc"
----
Собранные HTML файлы доступны в каталоге *target/doc*. Они автоматически проверяются на корректность внутренних ссылок.

[[build-update]]
=== Change update
Build and publish on https://bgerp.org/update update package with a <<workflow, change>>.

[IMPORTANT]
====
Public SSH key or the developer might be added for *update@bgerp.org*.
Before you publish a change update, make sure, that `ssh update@bgerp.org` session works by you.
====

Clean before publish:
[source, bash]
----
bash -c "./gradlew clean buildClean "
----

If there are some <<documentation, documentation>> or <<java-lib, Java libraries>> changes:
[source, bash]
----
bash -c "./gradlew buildUpdateLib buildDoc"
----

Or only application changes:
[source, bash]
----
bash -c "./gradlew buildUpdate"
----

For publish operation make the command:
[source, bash]
----
bash -c "./gradlew publishUpdate"
----

Of course, all the Gradle tasks might be started together, so the typical case is:
[source, bash]
----
bash -c "./gradlew clean buildClean buildUpdate buildDoc publishUpdate"
----

All the updates packages are copies to Web directory: `https://bgerp.org/update/PROCESS_ID`
The <<change-file, change file>> has also copied, and all documentation links there starting from `https://bgerp.org/doc` 
are automatically replaced to the `https://bgerp.org/update/PROCESS_ID/doc`.

Пользователи имеют возможность <<kernel/install.adoc#installer, установить>> пакет с помощью команды *install*,
сообщить о выявленных недочётах и откатиться на предыдущую версию командой *update* в случае невозможности работать с ними далее.
Возможна многократная публикация до выявления всех недочётов, после чего именение <<workflow, переносится>> 
в основную ветку и <<build-erp, публикуется>> очередное обновление.

[[build-erp]]
=== Release
CAUTION: Check <<unit-test, Unit tests>> running.

Сборка производится с *master* ветки и может включать несколько изменений, <<workflow, перенесённых>> на неё.

IMPORTANT: Для каждого переноса делать отдельный GIT push, для корректной <<publish-source, публикации>> в открытом репозитарии. 

В зависимости от наличия в обновлении <<java-lib, сторонних библиотек>> выполнить команды:
[source, bash]
----
bash -c "./gradlew buildClean buildUpdate"
----
либо:
[source, bash]
----
bash -c "./gradlew buildClean buildUpdateLib buildUpdate"
----

Далее:
[source, bash]
----
bash -c "./gradlew patchChanges rss publishBuild publishCommit"
----

Check the release commit and make:
[source, bash]
----
git push
----

Build <<build-docker, Docker image>>.

Merge the latest state of the master on <<documentation, documentation>> branch.

[[build-docker]]
=== Docker
[source]
----
docker login --username bgerp
----
Input access token.

Go in directory `build/docker`
[source]
----
bash files.sh
docker build . -t bgerp/bgerp
docker push bgerp/bgerp
----

[[unit-test]]
=== Unit тесты
Используется фреймворк JUnit, каталог `srcx/test`. 
Проверка отдельных алгоритмов, тесты не зависят друг от друга, не работают с БД.

Запуск локально командой:
[source, bash]
----
bash -c "./gradlew clean test"
----

[[integration-test]]
=== Интеграционный тест
Используется фреймворк TestNG, каталог `srcx/itest`.

Интеграционный тест производит сборку, установку и запуск приложения с реальной БД.
Далее в браузере эмулируется различные действия пользователя с проверкой результата.
Тесты образуют граф зависимостей, определяющий порядок и параллельность выполнения.
После успешного прохождения тестов дамп заполненной БД <<test-integration, выгружается>> для http://demo.bgerp.ru

Файл для установки должен быть собран предварительно командой.
[source, bash]
----
bash -c "./gradlew buildErp"
----

`sudo` необходим для установки в стандартный */opt* каталог.

WARNING: Тест пересоздаст базу с именем *bgerp* и переустановит сервер в */opt/BGERP*

[source, bash]
----
sudo GRADLE_OPTS=-Xmx1000m ./gradlew -Ptest.single='ru.bgerp.itest.RunServerTest' -Pdb.host=DB_HOST -Pdb.user=ROOT_USER -Pdb.pswd=ROOT_PSWD integrationTest
----
Параметры DB_HOST, ROOT_USER, ROOT_PSWD - для доступа к MySQL серверу, где будет создана тестовая БД.

==== Selenium e-to-e тест
Может выполнять впоследствия действия на запущенном сервере.
Необходима установка *chromedriver* и указание его в пути.

[source, bash]
----
GRADLE_OPTS=-Xmx1000m ./gradlew -Ptest.single='ru.bgerp.itest.SeleniumTest' -Pwebdriver.chrome.driver=/usr/lib/chromium-browser/chromedriver integrationTest
----

[[gitlab-ci]]
=== GitLab CI
В файле link:../../.gitlab-ci.yml[.gitlab-ci.yml] настроен автоматический запуск задач на каждый коммит в GIT.
Различные задачи выполняются в разных ветках <<workflow, Workflow>>.
Ниже описание CI задач. 

[[test-unit-and-doc]]
==== test-unit-and-doc
Запускает <<unit-test, Unit тесты>>, <<build-doc, сборку и проверку документации>>.

[[test-integration]]
==== test-integration
Запускает <<integration-test, интеграционный тест>>.

[[publish-doc]]
==== publish-doc
Запускает <<build-doc, сборку и проверку документации>>, при отсутствии ошибок - публикует её на http://bgerp.ru/doc/manual.

[[publish-source]]
==== publish-source
Публикует актуальные исходные коды из `master` в открытый репозитарий https://github.com/pingvin235/bgerp
Данный способ выбран для уменьшения размера открытого репозитария и сокрытия удалённых ранее файлов из истории. 
