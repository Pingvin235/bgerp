= Проект
:toc:
:toclevels: 4

BGERP - большой проект. Его разрабатывали живые люди, которые родились несовершенными и после долго учились.
В основном - путём проб и ошибок. В данной статье собранны актуальные рекомендации, представленные однако малым количеством <<samples, кода>>.
Поэтому следовать им необходимо, применяя *Правило бойскаута*. 

IMPORTANT: Оставь место стоянки чище, чем оно было до твоего прихода.

Редактируя тот или иной блок кода необходимо уменьшать использование устаревших подходов, методов, классов.
Писать новый код, используя последние рекомендации и параллельно корректировать смежный код.
При тестировании <<workflow, изменения>> будут одновременно проверены и улучшения кода.
Таким образом постепенно качество кода будет расти.
В дальнейшем будут внедрены формальные метрики качества кода: количество предупреждений компилятора, проверки формата и т.п.

[[workflow]]
== GIT Workflow
В таблице описаны GIT ветки. 
Для работы с ними используется link:https://docs.google.com/document/d/15NptRsx1qrdiWEew23EFz6gbxD6S12VQpnBQ6X9NbiQ/edit?usp=sharing[стандартный GIT Workflow], 
сходный, например, с ядром Linux.
Основная идея - мерджи производятся только "вниз": с основной ветки на вторичные для получения актуального состояния.
На основную ветку всё переносится посредством патчей, поэтому она имеет линейную структуру.
Вторичные ветки впоследствии могут быть удалены, поскольку вся аггрегированная информация из них содержится в основной.

[cols="a,a,a,a", options="header"]
|===
|Ветка
|Базируется на
|Назначение
|<<gitlab-ci, CI>>

|*master*
|
|Стабильная версия программы.
|<<test-integration>>, <<publish-source>>

|*p<ID процесса>-short-description*
|master
|Изменение программы и документации.
|<<test-unit-and-doc>>

|*documentation*
|master
|Корректировки документации. Долгоживущая ветка, периодически переносится на master.
|<<publish-doc>>

|*documentation-change-request*
|documentation
|Предложения по корректировке документации, могут быть смерджены обратно на documentation.
|<<test-unit-and-doc>>
|===

Основная ветка проекта - *master*, с неё собираются <<build, сборки>>.
[square]
* Каждое *изменение* должно базироваться на процессе в BGERP BiTel, в котором происходит весь обмен информацией по нему.
* *Идентификатор изменения* - строка *p<ID процесса>*, например *p13455*
* Для каждого изменения создаётся отдельная ветка GIT на базе основной, название начинающееся с идентификатора изменения, разделители - дефисы. 
Например: *p11788-link-filter-title*
* В процессе разработки в ветке допускается любая стратегия коммитов: промежуточные коммиты, ответвления, откаты коммитов.
Рекомендуется пушить промежуточные состояния, используя GIT репозитарий как резервную копию.
* На ветку изменения могут быть периодически смерджена основная ветка для синхронизации с актуальным состоянием и *обязательно перед переносом*.
* Необходимые правки <<documentation, документации>> производятся одновременно с модификацией исходного кода.
* Пакет тестового обновления для клиента, равно как и документацию, можно <<build-update, собирать и опубликовать>> из ветки.
* Ветка должна добавлять файл *build/change.<ID процесса>.txt*, при его отсутствии он создаётся автоматически при <<build-update, сборке изменения>>.
В файле на разных строках должны быть описаны новые функции, исправления и прочие изменения. 
Формат идентичен с *changes.txt*, в который информация переносится автоматически при публикации <<build-erp, обновления>>. 
* По завершению разработки и тестирования у клиента необходимо запросить *перенос* ветки с изменением на основную ветку, 
для этого процесс BGERP перевести в статус *Приёмка*.
* После проверки процесс закрывается, а изменение переносится в виде единственного коммита, 
с комментарием начинающимся с идентификатора изменения в основную ветку.
* Ветка разработки впоследствии может быть удалена. Автор изменения может быть установлен по идентификатору в комментарии.

[IMPORTANT]
====
Невозможно одновременно тестировать несколько изменений параллельно на одной системе и пользоваться ими.
Каждое изменение будет перетирать другое при установке обновления.
В крайнем случае допустимо создание сборочных веток, на которые смердживаются несколько веток изменений.
====

=== Настройка GIT
Пример настройки *.gitconfig*:
[source]
----
[user]
	email = shamil@company.com
	name = Shamil Vakhitov
[credential]
	helper = store
[core]
	autocrlf = false
	fileMode = false
[pull]
	rebase = true
----

=== Команды GIT
Почистить все ссылки на несуществующие более удалённые ветки:
[source]
----
git remote prune origin
----

Получение последних обновлений основной ветки не будучи в ней:
[source]
----
git fetch origin master:master
----

[[documentation]]
=== Документация
Исходные файлы в формате AsciiDoctor размещаются в каталоге *srcx/doc* проекта.
Модификация исходных кодов программы и документации выполняется одновременно в ветке <<workflow, изменения>>.
Примеры форматирования и рекомендации можно посмотреть <<samples.adoc#, здесь>>.
Документация может быть <<build-doc, собрана>> локально с ветки и <<build-update, включена>> в пакет обновления.

Публикация документации <<publish-doc, происводится>> с ветки <<workflow, ветке>> *documentation*.
Для предложения больших правок следует создать префиксом *documentation-*, начинающуюся с данной.

[[ide]]
== Настройки IDE
=== Форматирование 
IDE либо редактор должны быть настроены для отображения пробельных символов.

image::_res/ide_format.png[width='600px']

Проект следует общепринятым соглашениям для оформления кода по каждому из используемых языков программирования.
Отступы: 4 пробела для Java, табуляторы - для всего остального.
Однако в силу исторических причин, многие файлы форматированы по-разному. 
На снимке выше видны например не рекомендуемые в данный момент *для Java* отступы табуляторами.

При приведении в норму формата файлов следует учитывать следующие правила:
[arabic]
. Все новые файлы должны быть корректно форматированы.
. Ни в коем случае не применять оба символа отступов в одном файле: табуляторы и пробелы. Файл в таком случае становится нечитаемым в некоторых редакторах. 
При обнаружении подобных случаев - приводить все отступы в файле к рекомендуемому формату.
. Осторожно совмещать форматирование файлов с внесением <<#workflow, изменений>>, это может существенно усложнить анализ в дальнейшем.

[[format-java]]
==== Java
Форматирование Java кода должно соответствовать *Java Conventions* со следующими изменениями.
Описано для форматера Eclipse.

Настройки в *Windows - Preferences - Java - Code style - Formatter*. 
Необходимо открыть стандартный форматтер и сохранить под новым именем, изменив параметры:
[square]
* *Indentation - Tab policy* - *Spaces only*
* *Indentation* - *Tab size* - *4*
* *Line Wrapping* - *Maximum line width*  - *150*

*Window - Preferences - Java - Code style - Organize Imports* в двух полях поставить 99 и 1.

Готовый файл форматера в формате Eclipse: link:../../.vscode/formatter.xml[formatter.xml]

=== Eclipse
В данный момент наиболее удобное решение.  
Загрузить *Eclipse for Java EE*, эта сборка уже содержит GIT клиент, редакторы JSP и XML.

Установить плагины:
[square]
* *Buildship Gradle* - поддержка Gradle;
* *AsciiDoctor* - правка документации;
* *MoreUnit* - удобная работа с Unit тестами.

Вызвать правым кликом на проекте меню *Refresh Gradle Project*.
Его же вызывать при любом изменении библиотек проекта.

*Window - Preferences - General - Editors - Text Editors* установить галочку *Show whitespace characters*

Импортировать <<#format-java, форматер Java>> в *Window - Preferences - Java - Codestyle - Formatter*.

=== VS Code
Более быстрая чем Eclipse, лучше поддержка JavaScript, Gradle. 
Недостатки:
[square]
* почти нет поддержки JSP;
* хуже редактор AsciiDoc.

Примеры настройки можно link:../../.vscode/readme.txt[посмотреть] в каталоге `.vscode` в корне проекта.
Форматер Java и отображение пробельных символов там уже включены.

[[ide-run]]
=== Запуск
Параметры для запуска:
[square]
* Main class: ru.bgerp.Server
* Program arguments: start
* VM arguments: -Dbgerp.setup.data=bgerp_test
* Classpath: *User entries - Advanced - Add folders* нажать и добавить каталог текущего проекта.

bgerp_test.propertes файл должен лежать в корне проекта.
Его можно скопировать из bgerp.properties, он не будет сохранён в GIT. 

Изначальную БД взять по ссылке http://demo.bgerp.ru/bgerp.sql , это результат запуска <<integration-test, интеграционного теста>>. 

[[devm]]
=== Методика разработки для клиента
BGERP запускается в IDE, с подключением к удалённой базе и биллингу (при необходимости). 
По окончании разработки удалённая база клиента наполнена актуальной конфигурацией и необходимо только обновить сам продукт.
[square]
* Подключаться к клиенту по SSH, пробрасывая соединение к БД и при необходимости к биллингу.
Пример: *ssh user@X.X.X.X -L3307:127.0.0.1:3306 -L8081:Y.Y.Y.Y:8080* 
* Создать свой *bgerp_customer.properties* файл, в нём можно прописывать параметры доступа и конфигурацию. Он не сохранится в GIT.
В нём же можно переопределить URL для подключения к биллингу на locahost.
* Переопределить порт для BGERP, тогда можно будет сохранять в браузере пароли под конкретного клиента.
* Создать конфигурацию запуска в IDE с данным properties.
* Можно поправить *.gitignore* для сохранения custom файлов клиента, если работа происходит в форке.

[[structure]]
== Структура проекта
BGERP представляет из себя standalone Java приложение с Web интерфейсом.
Запуск во время разработки может быть <<ide-run, произведён>> прямо в IDE.
Перечень каталогов проекта с описанием.
[square]
* *bin* - скомпилированные IDE Java классы;
* *build* - файлы, относящиеся к <<build, сборке>>;
* *docpattern* - шаблоны плагина <<plugin/document/index.adoc#, Document>>;
* *dyn* - <<kernel/extension.adoc#dyn, динамический код>> с примерами;
* *dyn.ext* - в каталог можно смонтировать динамические классы на машине <<devm, клиента>>; 
* *filestorage* - хранилище файлов при запуске в IDE;
* *lib* - Java библиотеки, не подключенные через <<java-lib, Gradle>>;
* *plugin* - объявления <<plugin, плагинов>>;
* *src* - Java исходные коды;
* *srcx* - исходные файлы <<documentation, документации>>, <<unit-test, Unit тестов>>, <<integration-test, интеграционного теста>>, утилит для сборки; 
* *webapps* - корень <<js-lib, Web приложения>>;
* *work* - каталог создаётся Tomcat для компиляции JSP файлов. 

[[custom-level]]
=== Уровни кастомизации
Одним из изначальных приоритетов системы была расширяемость и гибкость.
Поэтому стандартный функционал может быть <<kernel/extension.adoc#tech-choice, расширен>> несколькими способами.

Следует однако понимать, что наиболее эффективный путь разработки и долгосрочной поддержки функциональности 
- реализация в виде штатного плагина либо части ядра, с вынесением необходимого минимума параметров в конфигурацию.
JEXL скрипты либо динамический код могут быть использованы для быстрого прототипирования,
либо реализации *исключительно специфичной для данной инсталляции* логики.

Практика показывает, что из всего набора кастомизированных попыток постепенно 
выявляются удачные решения, которые подходят значительному числу пользователей.
Такие необходимо переносить в основной код, делая частью системы и совместно развивая её дальше.

Следующая диаграмма визуально отображает данную динамику трансформации совокупной массы программного кода разных типов.
Объём кода учитывается для всех клиентов, бОльший объём из разрозненных *решений* преобразуется в меньший объём более универсального кода единого *продукта*.
 
[ditaa]
----
+--------------+   +--------------+  +-----------------------+
|              |   |              |  |                       |
|              |   |              |  |                       |
|  Custom JSP  |   |  Dyn Code    |  |      Configuration    |
|              |   |              |  |                       |
|              |   |              |  |         +JEXL         |
|              |   |              |  |                       |
+------+-------+   +-----------+--+  +-+----------+----------+
       |                       |       |          |
       v                       v       v          v
+------+-------+           +---+-------+-+ +------+------+
| Standard JSP |           |  Java Code  | |Configuration|
+--------------+           +-------------+ +-------------+
----

=== Библиотеки
[[java-lib]]
==== Java  
При link:../../build/bgerp/files/erp.sh[запуске] программы подключаются JAR файлы из следующих каталогов:
[square]
* *lib/app* - непосредственно <<build-erp, классы приложения>>;
* *lib/ext* - сторонние библиотеки, необходимые для работы;
* *lib/custom* - дополнительные библиотеки для <<kernel/extension.adoc#dyn, динамического кода>> и JEXL скриптов.  

Сторонние библиотеки поставляются в отдельном <<build-update, пакете обновления>>. 
Артефакты и версии указываются в файле link:../../build.gradle[build.gradle] для конфигурации *bgerp*.

IMPORTANT: Для данной конфигурации не используются транзитивные зависимости, все необходимые версии библиотек должны быть явно указаны.
Рекомендуемый подход - последовательное добавление минимального набора библиотек до получение работоспособного приложения. 
Таким образом уменьшается размер пакета и упрощается сопровождение. 

Для IDE Eclipse для ускорения изначальной инициализации проекта по-умолчанию отключена загрузка исходных кодов и документации.
[snippet, from="ec", to="}"]
link:../../build.gradle#L18-L24[build.gradle]

[[js-lib]]
==== JS
JS библиотеки располагаются в следующих каталогах:
[square]
* `webapps/js` - располагаются JS файлы самого приложения: ядра и <<plugin, плагинов>>;
* `webapps/lib` - сторонние библиотеки.

Для упрощения отладки используются не минифицированные версии библиотек.

Некоторые сторонние библиотеки пропатчены, все изменения сопровождены комментариями, пример:
[snippet, from="con", to=");", remove-leading="		"]
link:../../webapps/lib/jquery-ui-1.12.1/jquery-ui.js#L8923-L8930[webapps/lib/jquery-ui-1.12.1/jquery-ui.js]

[[action]]
== Actions
Принципиальная структура обработки запросов изображена ниже.
[ditaa]
----
+----------------+             AJAX
|                |    +----+           +-------------+     +----------+
|      HTML      |    | JS |           |             |     |{s}       |
|                +-=->+    +-----+=+-->+ Java Action +<-=->+ MySQL DB |
|                |    |    |           |             |     |          |
|                |    |    +<----+=+---+             |     +----------+
|                |    |    | CHANGE OK +------+------+
|                |    |    | ANY ERROR        |
|                |    |    |                  :
|       +--------+    |    |                  |
|       |  HTML  |    |    |                  v
|       |        +<-=-+    |           +------+------+
|       |Fragment|    |    +<----+=+---+     JSP     |
|       +--------+    +----+   READ    +-------------+
|                |
+----------------+
----

Этапы обработки:
[square]
. Запрос формируется с помощью JS из HTML формы и отправляется в метод класса Java Action.
. На запрос изменения отправляется только подтверждение - JSON документ со статусом OK.
. Любое исключение в процессе работы Action приводит к отправке на клиентскую сторону JSON со статусом ERROR.
. На запрос чтения данных в случае корректной обработки отправляется фрагмент HTML документа, встраиваемый на клиенте в нужное место.
Например, таблица со списком пользователей.

Actions определяются в struts-config*.xml файлах, имя метода передаётся в параметре *action*.

Пример объявления action с форвардом.

[snippet, from="<ac", to="on>", remove-leading="		"]
link:../../webapps/WEB-INF/struts-config-blow.xml#L4-L7[webapps/WEB-INF/struts-config-blow.xml]

Акшены должны расширять класс javadoc:ru.bgcrm.struts.action.BaseAction[], методы возвращать результат через вызов *processUserTypedForward* либо *processJsonForward*.
Первый метод обрабатывается JSP страницей-форвардом и высылает HTML на клиент. Второй - предназначен для выполнения изменений и возвращает только JSON формат с результатом выполнения.

Все параметры запроса передаются в объекте javadoc:ru.bgcrm.struts.form.DynActionForm[], он содержит вспомогательные методы для получения параметров разных типов.

CAUTION: Не использовать устаревший формат акшенов с параметрами HttpClientRequest и HttpClientResponse, они есть в form. 

Фрагмент читающего акшен метода с форвардом.
[snippet, from="pu", to="}", remove-leading="    "]
link:../../src/ru/bgerp/plugin/blow/struts/action/BoardAction.java#L34-L53[ru.bgerp.plugin.blow.struts.action.BoardAction]

Результат перенаправляется на JSP страницу:
link:../../webapps/WEB-INF/jspf/user/plugin/blow/board/show.jsp[webapps/WEB-INF/jspf/user/plugin/blow/board/show.jsp].

В этом же *form* следует передавать данные для отрисовки JSP, за исключением различных вспомогательных справочников.
Для этого используется поле *response* формы.
При *responseType=json*, всё отправленное в response сериализуется в JSON, именно поэтому справочники следует помещать в HttpResponse.
Если метод не требует соединения к БД - используйте метод с параметром javadoc:ru.bgcrm.util.sql.ConnectionSet[].

[snippet, from="pu", to="}", remove-leading="    "]
link:../../src/ru/bgcrm/plugin/dispatch/struts/action/DispatchAction.java#L46-L52[ru.bgcrm.plugin.dispatch.struts.action.DispatchAction]

Исключение прерывает выполнение акшена, возвращается ошибка. Всегда в JSON формате.
Исключение с классом javadoc:ru.bgcrm.model.BGMessageException[] используется для прерывания акшена с высылкой уведомления. То есть это штатная ситуация.
В методах акшенов рекомендуется указывать *throws java.lang.Exception*, для генерации своих исключений - *new BGExeption()*.

Пример акшена с обработкой параметров, исключениями и <<localization, локализацией>>.
[snippet, from="pu", to="}", remove-leading="    "]
link:../../src/ru/bgerp/plugin/blow/struts/action/BoardAction.java#L55-L74[ru.bgerp.plugin.blow.struts.action.BoardAction]

[[cache]]
=== Кэши
Кэширование во внутренних Map и List используется для ускорения в сотни раз получения справочных значений при 
<<ui, построении UI>>, либо <<kernel/extension.adoc#jexl-process-context, JEXL скриптах>>.
Map объекты позволяют получать объекты по коду, List - упорядоченный по алфавиту список значений.
Примеры кэшируемых объектов: пользователи, их группы, типы процессов, конфигурации.
Полный список можно увидеть в классе link:../../src/ru/bgcrm/servlet/filter/SetRequestParamsFilter.java[ru.bgcrm.servlet.filter.SetRequestParamsFilter]

IMPORTANT: Рекомендуется всегда когда возможно использовать в первую очередь кэши для получения справочников, избегая лишних запросов к БД.

Редактирование справочников происходит напрямую с БД, после редактирования кэш сбрасывается.
[snippet, from="pu", to="}"]
link:../../src/ru/bgcrm/struts/action/admin/UserAction.java#L94-L100[ru.bgcrm.struts.action.admin.UserAction]

[[ui]]
=== JSP UI
HTML страницы отрисовываются на серверной стороне <<kernel/extension.adoc#jsp, JSP шаблонами>>, получая даннные от Actions и <<cache, кэшей>>.
UI реализован из унифицированных компонентов таким образом, что в большинстве случаев что не требуется устанавливать стили,
писать дополнительные JS обработчики. Примеры <<sample-jsp-ui, кода JSP UI>>. 

==== Теги
Компоненты выполнены как JSP теги, объявлены в каталоге `webapps/WEB-INF/tags`.
<<ide, IDE Eclipse>> поддерживает автодополнение при их использовании.

image::_res/ide_jsp_tag.png[width='600px']

Обзор использования тегов с элементами управления пользователя вы можете посмотреть в файле link:../../webapps/test.jsp[webapps/test.jsp], 
для выполнения шаблона наберите в браузере http://<host>:<port>/test.jsp, для DEMO системы: http://demo.bgerp.ru/test.jsp

Пункты меню, устанавливающие соответствие между URL оснастки и Java Action определяются для ядра в файле 
link:../../webapps/WEB-INF/jspf/user/menu.jsp[webapps/WEB-INF/jspf/user/menu.jsp], для плагинов - через точку <<plugin-ui-menu, расширения>>.

==== Функции
JSP функции объявлены в каталоге `webapps/WEB-INF/tld`.
Также как и для тегов для IDE поддерживает автодополнение.
Используются, например, для <<sample-date-format, форматирования выводимых времён>>.

==== Идентификация элементов
В HTML DOM все идентификаторы элементов глобальные с использованием атрибутов `class` и `id`. Их довольно сложно отслеживать на предмет 
используемости и уникальности, а кроме того приложение обязательно должно быть одностраничным, что мешает сохранять состояние на скрытых элементах. 
Для обхода этого неудобства в проекте используется привязка JS обработчиков через HTML атрибуты onClick и т.п., с применением конекстной переменной `this`.
Либо генерируется уникальный идентификатор с помощью JSP функции `u:uiid()`, который также подставляется в сгенерированный вызов JS.

==== Сохранение контекста
JSP страница хранит все переменные глобально. В сочетании с инклудами и большими шаблонами это может создавать неудобства.
Для обхода проблемы используется тег восстановления контекста `<u:sc>`, все переменные созданные внутри него сбрасываются при выходе.

[[plugin]]
== Плагины
Всякая логически обособленная функциональность должна быть вынесена в плагин.
Особенностью плагинов является их изолированность. Каждый плагин работает с ядром,
ядро не знает особенностей конкретного плагина, плагины не знают друг о друге.
Под *знанием* тут подразумевается полагание на конкретное API, вызовы.

В каких местах производится правка для плагина:
[square]
* XML объявление плагина *plugin/name.xml*, там же объявляются точки расширений.
* Таблицы БД при необходимости создаются и модифицируются в *build/update/patch.sql*
* Java код плагина в пакете *ru.bgerp.plugin.name*
* Java библиотеки подключать в *build.gradle* после комментария: "библиотеки, попадающие в сборку BGERP"
* JS код плагина в файле *webapps/js/name.js*, подключается через точку расширения в XML объявлении.
* Actions плагина в файле *webapps/WEB-INF/struts-config-name.xml*
* Действия из обычного интерфейса должны быть объявлены в *action/plugin.xml* для контроля прав.
* JSP плагина в *webapps/WEB-INF/jspf/user/plugin/name*
* Для добавления плагина в сборку править *build/update/build.xml*

=== XML декларация
[snippet]
link:../../plugin/blow.xml[]

В файле определяются точки расширения:
[square] 
* JSP шаблоны;
* JS файлы;
* *package* - пакет плагина, в котором должен быть размещён главный класс.

=== Java класс плагина
link:../../src/ru/bgerp/plugin/blow/Plugin.java[ru.bgerp.plugin.blow.Plugin]

В классе плагина могут определяться слушатели событий:
[snippet, from="pu", to="}", remove-leading="	"]
link:../../src/ru/bgcrm/plugin/slack/Plugin.java#L14-L20[ru.bgcrm.plugin.slack.Plugin]

[[plugin-ui-menu]]
=== Пункты меню
Объявление точки расширения в XML декларации:
[snippet, from="<en", to=">", remove-leading="	"]
link:../../plugin/blow.xml#L4-L4[plugin/blow.xml]

Добавление пункта с помощью тега JSP: link:../../webapps/WEB-INF/jspf/user/plugin/blow/menu_items.jsp[webapps/WEB-INF/jspf/user/plugin/blow/menu_items.jsp]

[[plugin-js]]
=== JavaScript
Объявление точки расширения в XML декларации:
[snippet, from="<en", to=">", remove-leading="	"]
link:../../plugin/blow.xml#L5-L5[plugin/blow.xml]

Файл со скриптом: link:../../webapps/js/pl.blow.js[webapps/js/pl.blow.js]

[[localization]]
== Локализация
Все сообщения в логах не локализуются и выводятся на английском языке.
Локализуется интерфейс и сообщения, адресованные пользователю системы.
Язык системы задаётся глобально в <<kernel/setup.adoc#config, конфигурации>>.
Файлы локализации размещаются в *plugin/i18n* в формате XML.

Ключом локализирующей фразы выступает первая запись на любом языке, например русском:
[source, xml]
----
<p><ru>Требуется повторная авторизация</ru><en>Re-authorization is required</en></p>
----

В коде JSP шаблона вызов выглядит следующим образом:
[source, jsp]
----
$('#loginForm').dialog({
	modal: true,
	draggable: false,
	resizable: false,
    title: "${l.l('Требуется повторная авторизация')}",
    position: { my: "center top", at: "center top+100px", of: window }
});
----

Локализация может выполняться в JSP шаблонах и Java акшенах. В JS коде локализация доступна, только если он генерируется JSP.

При выполнении акшена в объект *l* передаётся локализационный контекст, содержащий фразы для ядра и вызываемого плагина.

Новые локализирующие фразы должны добавляться в начало списка в файле.
При необходимости сторонние разработчики могут выполнять локализации в ветках и высылать запросы на портирования в ствол проекта аналогично любым другим патчам. 

NOTE: Для отключения в момент разработки кэширования локализаций установите в конфигурации *localization.cache=0*

== Именование
=== Переменные конфигураций, функции JS, HTTP StyleId
[square]
* Все переменные конфигурации от плагинов начинать как <plugin>:
* Все функции JS плагинов начинать с префикса <plugin>-
В других местах тире запретить в названии функции.
* Все идентификаторы (style id) DOM элементов для плагинов начинать как <plugin>-
В других местах тире запретить в названиях  идентификаторов.

=== База данных
1) Таблицы и поля в них именовать с нижним подчёркиванием.
process_id
param_id

=== Переменные Java, параметры HTTP запросов, переменные в JSP
В camelCase нотации:
processId
paramId

=== Дата - поле сущности
Если в поле только дата, то:
createDate - Java - тип java.util.Date
create_date - БД - тип date

Если в поле дата + время, то:
createTime - Java - тип java.util.Date
create_dt - БД - тип datetime

=== Дата - период сущности
В бинах дату периода хранить с типом java.util.Date с именем:
dateFrom
dateTo

Соответственно методы получения и установки:
setDateFrom
setDateTo
getDateFrom
getDateTo

CAUTION: Не использовать для хранения в бинах Calendar.
Если нужно конверить в календарь или из календаря - использовать TimeUtils.

Если нужно хранить время, то делаем:
timeFrom
timeTo

Также тип java.util.Date.

Calendar использовать во всяких калькуляторах/тарификаторах, когда реально нужно постоянно двигать дату.

В базе использовать поля from_date и to_date, тип date.

from_dt, to_dt - тип datetime.

Неограниченные даты - NULL.

[[samples]]
== Примеры кода
Так как система очень быстро меняется, то здесь собираются примеры актуального кода, рекомендуемого к использованию.
Сниппеты извлекаются непосредственно из исходных файлов проекта, поэтому всегда достоверны.
При необходимости воспользуйтесь IDE для поиска классов или файлов.

=== Сохранение последних параметров запроса пользователя
Например, фильтров интерфейса. Используется метод *restoreRequestParams* в: javadoc:ru.bgcrm.struts.action.BaseAction[]

Сохранение значения:
[snippet, from="pu", to=");", remove-leading="	"]
link:../../src/ru/bgcrm/struts/action/MessageAction.java#L61-L67[ru.bgcrm.struts.action.MessageAction]

Восстановление:
[snippet, from="pu", to="}", remove-leading="	"]
link:../../src/ru/bgcrm/struts/action/MessageAction.java#L232-L244[ru.bgcrm.struts.action.MessageAction]

Сохранение плюс восстановление сразу:
[snippet, from="//", to=");", remove-leading="    "]
link:../../src/ru/bgcrm/struts/action/ProcessAction.java#L1086-L1090[ru.bgcrm.struts.action.ProcessAction]

=== Отображение на вкладке количества элементов
Например, количества связанных процессов. Сохраняется при первом вызове. 
Используется класс javadoc:ru.bgcrm.model.IfaceState[]

Обновление значения:
[snippet, from="// п", to="m);", remove-leading="        "]
link:../../src/ru/bgcrm/struts/action/ProcessAction.java#L1242-L1246[ru.bgcrm.struts.action.ProcessAction]

Отображение в JSP:
[snippet, from="<c:if", to="if>", remove-leading="						"]
link:../../webapps/WEB-INF/jspf/user/process/process/process_editor.jsp#L85-L99[webapps/WEB-INF/jspf/user/process/process/process_editor.jsp]

[[sample-date-format]]
=== Форматирование даты и времени
При форматировании дат и времени в Java либо JSP для независимости от текущей локали и унификации используются форматы вида:
[square]
* *ymd* - год, месяц, день;
* *ymdh* - год, месяц, день, час;
* *ymdhm* - год, месяц, день, час, минута;
* *ymdhms* - год, месяц, день, час, минута, секунда.

В Java коде для форматирования дат используется класс javadoc:ru.bgcrm.util.TimeUtils[], 
в нём же есть константы с форматами.

В JSP - функция `u:formatDate()`:
[snippet, from="<td", to="/td>", remove-leading="		"]
link:../../webapps/WEB-INF/jspf/user/plugin/task/task_list.jsp#L18-L19[webapps/WEB-INF/jspf/user/plugin/task/task_list.jsp]

=== Бины конфигурации
Для ускорения парсинга и валидации используются Java объекты с классом, наследующим javadoc:ru.bgcrm.util.Config[].
Например: link:../../src/ru/bgcrm/model/config/IsolationConfig.java[ru.bgcrm.model.config.IsolationConfig].
Данная конфигурация поддерживает конструктор с флагом валидации, что позволяет проверять синтаксис при сохранении.

Бины конфигурации могут быть получены и в JSP:
[snippet, from="<c:", to="/>"]
link:../../webapps/WEB-INF/jspf/user/plugin/task/task_list.jsp#L4-L4[webapps/WEB-INF/jspf/user/plugin/task/task_list.jsp]

[[sample-logging]]
=== Логирование
==== Java
Используется класс логгер javadoc:ru.bgerp.util.Log[], базирующийся на фрейморке <<kernel/extension.adoc#log4j, Log4j>>.
При запуске в IDE конфигурационный файл из дистрибутива link:../../build/bgerp/files/log4j.properties[build/bgerp/files/log4j.properties]
может быть скопирован в корень проекта и изменён требуемым образом.

Для логирования в <<action, actions>> использовать *protected* переменную `log`.

В Java классах создавать *static final* переменную класса:
[snippet, from="pub", to=");"]
link:../../src/ru/bgcrm/worker/MessageExchange.java#L16-L19[ru.bgcrm.worker.MessageExchange]

Вывод сообщения при исключении:
[snippet, from="try", to="}", remove-leading="					"]
link:../../src/ru/bgcrm/worker/MessageExchange.java#L60-L64[ru.bgcrm.worker.MessageExchange]

==== JS
Вывод отладки вместо console.log:
[snippet, from="con", to="};"]
link:../../webapps/js/crm.shell.js#L5-L12[webapps/js/crm.shell.js]

Включение вывода отладки:
[snippet, from="bg", to="se,"]
link:../../webapps/js/crm.js#L18-L21[webapps/js/crm.js]

=== Постраничный вывод
NOTE: AJAX функции в данном примере <<sample-jsp-ui, неактуальны>>.

Вывод результатов в JSP и отображение формы:
[snippet, from="<c:", to="sc>", remove-leading="		"]
link:../../webapps/WEB-INF/jspf/user/process/process/link_process_list.jsp#L74-L85[webapps/WEB-INF/jspf/user/process/process/link_process_list.jsp]

Java action:
[snippet, from="//", to=");", remove-leading="        "]
link:../../src/ru/bgcrm/struts/action/ProcessAction.java#L1233-L1235[ru.bgcrm.struts.action.ProcessAction]

[[sample-jsp-ui]]
=== JSP UI
Отправка AJAX для сохранения, выхода, либо восстановления данных в <<kernel/process/index.adoc#type, редакторе свойств типа процесса>>: 
[snippet, from="<div", to="/div>"]
link:../../webapps/WEB-INF/jspf/admin/process/type/properties.jsp#L194-L199[webapps/WEB-INF/jspf/admin/process/type/properties.jsp]

Рекурсивный инклуд:
[snippet, from="<c:", to="if>", remove-leading="					"]
link:../../webapps/WEB-INF/jspf/admin/user/check_tree_item.jsp#L48-L50[webapps/WEB-INF/jspf/admin/user/check_tree_item.jsp]

Инклуд результата выполнения акшена:
[snippet, from="<c:", to="/>", remove-leading="			"]
link:../../webapps/WEB-INF/jspf/admin/user/user/update.jsp#L161-L166[webapps/WEB-INF/jspf/admin/user/user/update.jsp]

Flex layout, использование констант из Java классов, кнопка вывода рядом с полем:
[snippet, from="<div", to="/div>", remove-leading="				"]
link:../../webapps/WEB-INF/jspf/user/search/search.jsp#L139-L158[webapps/WEB-INF/jspf/user/search/search.jsp]

Обновление оснастки при повторном переходе в неё:
[snippet, from="<script", to="/script>"]
link:../../webapps/WEB-INF/jspf/user/log/log.jsp#L22-L28[webapps/WEB-INF/jspf/user/log/log.jsp]

Отправка AJAX запроса, блокировка кнопки при долгом выполнении действия:
[snippet, from="<bu", to="on>"]
link:../../webapps/WEB-INF/jspf/admin/dynamic/dynamic.jsp#L16-L21[webapps/WEB-INF/jspf/admin/dynamic/dynamic.jsp]

[[build]]
== Сборка и публикация
Проект сконфигурирован в формате Gradle, конфигурационный файл link:../../build.gradle[build.gradle].
Для сборки и публикации помимо Java требуется Apache Ant и GNU утилиты, включая rsync. Операции могут выполнены на Linux, WSL, либо Mac.

NOTE: Здесь и далее команды приведены в расчёте на WSL окружение, в *NIX системах префикс `bash -c` не требуется.

[[build-doc]]
=== Документация
[source]
----
bash -c "./gradlew clean buildDoc"
----
Собранные HTML файлы доступны в каталоге *target/doc*. Они автоматически проверяются на корректность внутренних ссылок.

[[build-update]]
=== Изменение
Сборка и публикация на http://bgerp/update пакета обновления с <<workflow,  изменением>>.
Открытый SSH ключ разработчика должен быть добавлен для сессии update@bgerp.ru.

Для выкладывания пакета выполнить:
[source, bash]
----
bash -c "./gradlew clean buildClean buildDoc buildUpdate publishUpdate"
----

Если изменялись библиотеки, то:
[source]
----
bash -c "./gradlew clean buildClean buildDoc buildUpdateLib buildUpdate publishUpdate"
----

Пакет с изменением публикуется в каталог, содержащий код процесса, например: https://bgerp.ru/update/10646

Пользователи имеют возможность <<kernel/install.adoc#installer, установить>> пакет с помощью команды *install*,
сообщить о выявленных недочётах и откатиться на предыдущую версию командой *update* в случае невозможности работать с ними далее.
Возможна многократная публикация до выявления всех недочётов, после чего именение <<workflow, переносится>> 
в основную ветку и <<build-erp, публикуется>> очередное обновление.

[[build-erp]]
=== Обновление
Сборка производится с *master* ветки и может включать несколько изменений, <<workflow, перенесённых>> на неё.

IMPORTANT: Для каждого переноса делать отдельный GIT push, для корректной <<publish-source, публикации>> в открытом репозитарии. 

В зависимости от наличия в обновлении <<java-lib, сторонних библиотек>> выполнить команды:
[source, bash]
----
bash -c "./gradlew buildClean buildUpdate"
----
либо:
[source, bash]
----
bash -c "./gradlew buildClean buildUpdateLib buildUpdate"
----

Далее:
[source, bash]
----
bash -c "./gradlew patchChanges rss publishBuild publishCommit"
----

[[unit-test]]
=== Unit тесты
Используется фреймворк JUnit, каталог `srcx/test`. 
Проверка отдельных алгоритмов, тесты не зависят друг от друга, не работают с БД.

Запуск локально командой:
[source, bash]
----
bash -c "./gradlew clean test"
----

[[integration-test]]
=== Интеграционный тест
Используется фреймворк TestNG, каталог `srcx/itest`.

Интеграционный тест производит сборку, установку и запуск приложения с реальной БД.
Далее в браузере эмулируется различные действия пользователя с проверкой результата.
Тесты образуют граф зависимостей, определяющий порядок и параллельность выполнения.
После успешного прохождения тестов дамп заполненной БД <<test-integration, выгружается>> для http://demo.bgerp.org

Файл для установки должен быть собран предварительно командой.
[source, bash]
----
bash -c "./gradlew buildErp"
----

`sudo` необходим для установки в стандартный */opt* каталог.

WARNING: Тест пересоздаст базу с именем *bgerp* и переустановит сервер в */opt/BGERP*

[source, bash]
----
sudo GRADLE_OPTS=-Xmx1000m ./gradlew -Ptest.single='ru.bgerp.itest.RunServerTest' -Pdb.host=DB_HOST -Pdb.user=ROOT_USER -Pdb.pswd=ROOT_PSWD integrationTest
----
Параметры DB_HOST, ROOT_USER, ROOT_PSWD - для доступа к MySQL серверу, где будет создана тестовая БД.

==== Selenium e-to-e тест
Может выполнять впоследствия действия на запущенном сервере.
Необходима установка *chromedriver* и указание его в пути.

[source, bash]
----
GRADLE_OPTS=-Xmx1000m ./gradlew -Ptest.single='ru.bgerp.itest.SeleniumTest' -Pwebdriver.chrome.driver=/usr/lib/chromium-browser/chromedriver integrationTest
----

[[gitlab-ci]]
=== GitLab CI
В файле link:../../.gitlab-ci.yml[.gitlab-ci.yml] настроен автоматический запуск задач на каждый коммит в GIT.
Различные задачи выполняются в разных ветках <<workflow, Workflow>>.
Ниже описание CI задач. 

[[test-unit-and-doc]]
==== test-unit-and-doc
Запускает <<unit-test, Unit тесты>>, <<build-doc, сборку и проверку документации>>.

[[test-integration]]
==== test-integration
Запускает <<integration-test, интеграционный тест>>.

[[publish-doc]]
==== publish-doc
Запускает <<build-doc, сборку и проверку документации>>, при отсутствии ошибок - публикует её на http://bgerp.ru/doc/manual.

[[publish-source]]
==== publish-source
Публикует актуальные исходные коды из `master` в открытый репозитарий http://git.pzdc.de/pub/bgerp/bgerp/.
Данный способ выбран для уменьшения размера открытого репозитария и сокрытия удалённых ранее файлов из истории. 
